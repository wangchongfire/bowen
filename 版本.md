# 4-5ColumnList组件编码

使用props将App组件内的数据TestData传递到ColumnList子组件；

子组件定义接口ColumnProps

子组件使用defineProps接收，并使用PropType进一步确定list的类型为ColumnProps类型的数组；

此版本知识点：组件的定义和使用、props传值、interface、类型断言、TypeScript工具类型PropType<T>

```vue
<template>
    <div>
        <ul>
            <li v-for="column in list" :key="column.id">
                <img :src="column.avatar" :alt="column.title">
                <h5>{{ column.title }}</h5>
                <p>{{ column.description }}</p>
                <a href="#">进入专栏</a>
            </li>
        </ul>
    </div>
</template>
<script setup lang="ts">
import { PropType } from 'vue'

interface ColumnProps {
    id:number;
    title:string;
    avatar:string;
    description:string;
}

// eslint-disable-next-line no-undef
const props = defineProps({
  list: {
    type: Array as PropType<ColumnProps[]>,
    required: true
  }
})
</script>

```

```
<template>
  <div id="app">
    <ColumnList :list="testData"/>
    <div></div>
  </div>
</template>

<script lang="ts" setup>
import ColumnList, { ColumnProps } from './components/ColumnList.vue'
import 'bootstrap/dist/css/bootstrap.min.css'

const testData: ColumnProps[] = [
  {
    id: 1,
    title: 'test1的专栏',
    description: '这是的test1专栏，有一段非常有意思的简介，可以更新一下欧, 这是的test1专栏，有一段非常有意思的简介，可以更新一下欧',
    avatar: 'http://vue-maker.oss-cn-hangzhou.aliyuncs.com/vue-marker/5ee22dd58b3c4520912b9470.jpg?x-oss-process=image/resize,m_pad,h_150,w_150'
  },
  {
    id: 2,
    title: 'test2的专栏',
    description: '这是的test2专栏，有一段非常有意思的简介，可以更新一下欧',
    avatar: 'http://vue-maker.oss-cn-hangzhou.aliyuncs.com/vue-marker/5ee22dd58b3c4520912b9470.jpg?x-oss-process=image/resize,m_pad,h_100,w_100'
  }
]
</script>
```

# 4-6ColumnList组件使用Bootstrap美化

（一）Vue3项目安装Bootstrap

```
npm i bootstrap@5.3.0-alpha1
```

在main.ts文件中引入

```ts
import { createApp } from 'vue'
import App from './App.vue'
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'

createApp(App).mount('#app')
```

（二）设置默认图片

需求：当子组件接收的数据中缺少图片路径时，将其设置为默认图片

完成方式：

1. 更改接口ColumnProps，将avatar属性设置为可选属性
2. 使用computed加工list，如果list的avatar属性为空，则将其设置为默认路径
3. 使用require函数获取本地assets中的资源
4. v-for不在循环list，而是循环columnList

```typescript
interface ColumnProps {
  id: number;
  title: string;
  avatar?: string;//将avatar属性设置为可选属性
  description: string;
}
```

```typescript
const columnList = computed(() => {
    return props.list.map(item => {
        if(!item.avatar){
            item.avatar = require('@/assets/column.jpg');
        }
        return item;
    });
});
```

```vue
<template>
  <div class="row">
      <!-- 循环columnList -->
    <div class="col-4 mb-4" v-for="column in columnList" :key="column.id">
      <div class="card h-100 shadow-sm">
        <div class="card-body">
          <img class="card-img-top rounded-circle border border-light my-3" :src="column.avatar" :alt="column.title" />
          <h5 class="card-title">{{ column.title }}</h5>
          <p class="card-text">{{ column.description }}</p>
          <a class="btn btn-outline-primary" href="#">进入专栏</a>
        </div>
      </div>
    </div>
  </div>
</template>
```

# 4-7Global-Header组件编码

需求：编写一个全局通用的Header组件，根据父组件的传值显示不同内容

完成：

1. IUser类型
2. 子组件props接收，使用v-if指令根据user的数据决定是显示登录按钮，还是下拉菜单

```typescript
const userData:IUser = {//父组件中的数据
  isLogin:true,
  name:'jack',
  id:101
} 
```

```typescript
<script lang="ts" setup>
import { PropType } from 'vue';
interface IUser {
    isLogin: boolean;
    name?: string;
    id?: number;
}

// eslint-disable-next-line no-undef
const props = defineProps({
    user: {
        type: Object as PropType<IUser>,
        requerid: true
    }
});
</script>
```

# 4-8Dropdown组件基本功能编码

需求：将下拉菜单抽离为组件，编写为Dropdown组件

```typescript
<DropDown :name="user.name" />
```

```typescript
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps(['name']);
</script>
```

# 4-9Dropdown组件添加DropdownItem

需求：将下拉菜单的选项抽离为组件

完成：

1. 使用slot传递元素
2. ElementPlus 中的下拉菜单选项有disabled属性，可以控制禁用
3. DropdownItem组件使用props接收父组件的数据，决定是否禁用

父组件

```vue
const isDisabled = ref(true);

            <div v-else>
                <DropDown :name="user.name">
                    <DropdownItem>
                        <a>新建文章</a>
                    </DropdownItem>
                    <DropdownItem :disabled="isDisabled">
                        <a>管理账户</a>
                    </DropdownItem>
                    <DropdownItem>
                        <a>退出登录</a>
                    </DropdownItem>
                </DropDown>
            </div>
```

Dropdown组件

````vue
<template>
  <el-dropdown split-button type="primary">
    欢迎你 {{ name }}
    <template #dropdown>
      <el-dropdown-menu>
        <slot></slot>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps(['name']);
</script>
````

DropdownItem组件

```vue
<template>
    <el-dropdown-item :disabled="disabled">
        <slot></slot>
    </el-dropdown-item>
</template>
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps({
    disabled: {
        type: Boolean,
        default: false,
    }
})
</script>
```

# 5-3抽象验证规则

需求：抽离表单组件，抽离输入框组件；父组件在调用输入框组件时，要传入数组形式的验证规则，输入框组件根据根据验证规则验证输入的信息，并给出对应的错误提示。

子组件

```vue
<template>
    <div class="form-input">
        <slot></slot>
        <el-input 
        @blur="validateEmail"
        v-model="inputRef.val" autosize type="textarea" placeholder="Please input" />
        <p v-if="inputRef.error" v-text="inputRef.message"></p>
    </div>
</template>
<script setup lang="ts">
import { PropType, reactive} from 'vue';

const emailReg = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;

// 定义验证规则的接口
interface IRuleProp{
    type:'required' | 'email';
    message:string;
}
// 接受父组件传来的值，包括验证规则
// eslint-disable-next-line no-undef
const props = defineProps({
    rules:Array as PropType<IRuleProp[]>,
});

// 响应式的信息，
const inputRef = reactive({
    val:"",//输入框绑定的值
    message:'',//绑定的错误提示信息
    error:false,//输入信息是佛正确
});
// 遍历传入的数组，检验输入值是否符合每一个规则
const validateEmail = () => {
    if(props.rules){
        let allPassed = props.rules.every(rule => {
            let passed = true;
            inputRef.message = rule.message;
            switch(rule.type){
                case 'required':
                    passed = (inputRef.val !== '');
                    break;
                case 'email':
                    passed = emailReg.test(inputRef.val);
                    break;
                default:
                    break;
            }

            return passed;
        })
        inputRef.error = !allPassed;
    }
}
// const validateEmail = () => {
//     if(emialRef.val.trim() === ''){
//         emialRef.error = true;
//         emialRef.message = 'Can not be empty!!!';
//     }else if(!emailReg.test(emialRef.val)){
//         emialRef.error = true;
//         emialRef.message = 'Should be valid email!!!';
//     }
// }
</script>
```

表单验证组件

```vue
<template>
    <div class="container">
        <div class="form">
            <div class="title">登录博文专栏</div>
            <slot></slot>
            <el-button color="#626aef" >Default</el-button>
        </div>
    </div>
</template>
```

App.vue组件

```vue
<template>
  <div id="app">
    <ValidateForm>
      <ValidateInput :rules="emailRules">
        <div>邮箱：</div>
      </ValidateInput>
      <ValidateInput>
        <div>密码：</div>
      </ValidateInput>
    </ValidateForm>
  </div>
</template>

<script lang="ts" setup>
// 传给表单输入框验证的 校验规则
const emailRules: IRuleProp[] = [
  { type: 'required', message: '电子邮箱地址不能为空' },
  { type: 'email', message: '请输入正确的电子邮箱格式' }
]
</script>
```

# 5-4 v-model实现父子组件双向数据绑定

v-model博客连接：https://juejin.cn/post/7335437804628328498

需求：子组件内输入框内容更新后，父组件对应数据也要变

完成：

1. 输入框组件注册事件
2. @keyup触发注册的事件
3. 使用emit发送最新数据
4. 父组件数据被更新

````typescript
// 接受父组件传来的值，包括验证规则、双向绑定的数据modelValue
const props = defineProps({
    rules:Array as PropType<IRuleProp[]>,
    modelVal:String,
});

const emit = defineEmits(['update:modelValue']);
// 监听输入框的数据更新
const updateVal = () => {
    emit('update:modelValue',inputRef.val);
}
````

```typescript
//父组件
// 表单数据之邮箱数据的响应式
const modelVal = ref('init email');
```

# 5-5 inheritAttrs与v-bind='$attrs'

需求：让子组件内的input接收属性，而不是根元素

完成：

1. 父组件在调用子组件时，传入type属性type='text'
2. 子组件使用defineOptions设置inheritAttrs为false
3. 子组件的input设置v-bind='$attrs'

父组件

```vue
     <ValidateInput
        type="text"
        v-model:modelValue="modelVal"
       :rules="emailRules">
        <div>邮箱：</div>
      </ValidateInput>
```

子组件

```vue
<template>
    <div class="form-input">
        <slot></slot>
        <input 
        v-bind="$attrs"
        @blur="validateEmail"
        @input="updateVal"
        v-model="inputRef.val" autosize placeholder="Please input" />
        <p v-if="inputRef.error" v-text="inputRef.message"></p>
    </div>
</template>
<script setup lang="ts">
// 设置根组件不继承属性
defineOptions({
    inheritAttrs:false,
})
</script>
```

# 5-8 ValidateForm-使用插槽slot

需求：

1. 父组件如果没有传入按钮组件，则显示默认按钮
2. ValidateForm组件在提交时，会向父组件发送数据

完成：

1. 使用具名插槽
2. emit注册事件，父组件监听事件

子组件

```vue
<template>
    <div class="container">
        <div class="form">
            <div class="title">登录博文专栏</div>
            <slot></slot>

            <div @click="onFormSubmit">
                <!-- 具名插槽 -->
                <slot name="submit">
                    <!-- 父组件没有传递按钮元素，则显示下方的默认按钮 -->
                    <el-button>Default</el-button>
                </slot>
            </div>
        </div>
    </div>
</template>
<script lang="ts" setup>
import  { defineEmits } from 'vue';

const emit = defineEmits(['form-submit']);
const onFormSubmit = () => {
    emit('form-submit',true);
}
</script>
```

父组件

```vue
<ValidateForm @form-submit="handleFormSubmit">
  <template #submit>
        <el-button type="primary">Primary</el-button>
  </template>
</ValidateForm>
// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  // alert(flag);
  
}
```

# 5-9 ValidateForm-尝试父子组件通信

需求：父组件中获取子组件的实例，使用子组件暴露出的方法和变量

完成：

1. 子组件使用defineExpose来暴露需要暴露出去的变量
2. 父组件通过ref属性同名变量接收子组件的实例

子组件：

```typescript
defineExpose({
    validateInput,
})
```

父组件

```vue
	  <ValidateInput
        ref="inputRef"//通过ref属性来接收子组件的实例
        type="text"
        v-model:modelValue="modelVal"
       :rules="emailRules">
        <div>邮箱：</div>
      </ValidateInput>
      
   // 获取ValidateInput组件的实例
const inputRef = ref<any>();
// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  // alert(flag);
  console.log(inputRef.value);
  console.log(inputRef.value.validateInput());//通过子组件实例使用子组件方法
  
}   
```

# 5-10 ValidateForm编码-使用mitt库注册并触发事件

需求：父组件注册一个事件，子组件可以触发并传递参数过去

实现：

1. 安装mitt库
2. 编写UseMitt.ts文件
3. 父组件导入emitter并注册事件
4. 子组件导入emitter并触发事件实现组件通信

安装

```
npm i mitt --save
```

UseMitt.ts组件

```typescript
import mitt from 'mitt';
export const emitter = mitt();
```

父组件

```vue
<script lang="ts" setup>
import  { defineEmits, onUnmounted } from 'vue';
import {emitter} from '../hooks/UseMitt';

const callback = (testVal:string) => {
    console.log(testVal);
}
// 注册子组件创建完毕事件
emitter.on('form-item-created',callback);
onUnmounted(() => {
    emitter.off('form-item-created',callback);
})
</script>
```

子组件

```vue
onMounted(() => {
    emitter.emit('form-item-created',inputRef.val);
})
```

# 5-12 ValidateForm编写完毕

需求：表单组件上的提交按钮被点击时，父组件可以获取表单的总体验证结果

实现：

1. 使用mitt库将Input组件的校验函数（ValidateInput函数）作为参数传递给表单组件
2. 在Input组件的挂载完毕钩子函数中，将ValidateInput传递过去
3. 表单组件接收ValidateInput函数，存储到数组funcArr中
4. 在点击提交按钮时，表单组件的对应函数被触发，对数组进行处理
5. 数组中的函数依次被执行，所有函数的结果都为true时，最终结果为true
6. 将最终结果result通过form组件使用defineEmits注册的事件，传递给父组件
7. 父组件监听form组件注册的事件，接收result，并显示或进行其它操作

ValidateInput组件

```vue
onMounted(() => {
    emitter.emit('form-item-created',validateInput);
})
```

ValidateForm组件

```vue
<script>
// 定义存储validateInput函数的类型
type ValidateFunc = () => boolean;
const funcArr:ValidateFunc[] = [];

const callback = (func:ValidateFunc) => {
    funcArr.push(func);
}
// 注册子组件创建完毕事件
emitter.on('form-item-created',callback);
onUnmounted(() => {
    emitter.off('form-item-created',callback);
})

const emit = defineEmits(['form-submit']);
const onFormSubmit = () => {
    const result = funcArr.map(fn => fn()).every(item => item);
    emit('form-submit',result);
}
</script>
```

父组件

当前是App.vue，ValidateForm组件也可以在其它地方使用

```vue
<ValidateForm @form-submit="handleFormSubmit">父组件监听Validate组件注册的form-submit事件

// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  console.log('表单提交结果',flag);
  
}
```

# 6-5 引入vue-router并整理项目

配置vue-router的文件

```typescript
import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router'
import HomeView from '../views/HomeView.vue'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/login',
    name: 'login',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/LoginView.vue')
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
})

export default router


```

main.ts引入vue-router

```typescript
import { createApp } from 'vue'
import App from './App.vue'
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'
import ElementPlus from 'element-plus'
import 'element-plus/dist/index.css'
import router from './router'


const app = createApp(App)
app.use(ElementPlus).use(router);
app.mount('#app')
```

# 6-6 动态路由ColumnDetailView.vue的编写

需求：

1. 配置动态路由
2. 点击登录页面提交按钮，根据校验规则，通过后跳转首页

实现：

1. router配置文件中配置ColumnDetailView为动态路由
2. 首页 进入专栏 按钮可以传递参数，进入动态路由
3. 表单校验成功后，使用router.push()方法跳转到首页

router配置文件

```typescript
  {
    path: '/column/:id',
    name: 'column',
    component: () => import('../views/ColumnDetailView.vue')
  }
```

router-link标签的两种写法

```vue
<!-- <router-link :to="`column/${column.id}`">进入专栏</router-link> -->
            <router-link :to="{name:'column',params:{id:column.id}}">进入专栏</router-link>
```

LoginView.vue组件 router.push()跳转

```typescript
// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  console.log('表单提交结果',flag);
  if(flag){
    router.push('/');
  }
}
```

# 6-11 Vuex整合当前应用

需求：

1. GlobalHeader组件中根据全局状态显示登录注册按钮或者用户姓名
2. 表单验证成功后，更改全局状态为登录状态
3. 首页文章列表采用全局数据

实现：

1. 使用useStore和computed实现全局数据和组件显示的双向绑定

vuex配置文件，store文件夹下的index.tx文件

```typescript
import { createStore } from 'vuex';
import {ColumnProps,PostProps,testData,testPosts} from '../testData';

interface UserProps{
    isLogin:boolean;
    name?:string;
    id?:number;
}
export interface GlobalDataProps{
    columns:ColumnProps[];
    posts:PostProps[];
    user:UserProps;
}

export default createStore<GlobalDataProps>({
  state: {
    columns:testData,
    posts:testPosts,
    user:{isLogin:false},
  },
  getters: {
  },
  mutations: {
    login(state){
        state.user = {isLogin:true,name:'jack'};
    }
  },
  actions: {
  },
  modules: {
  }
})
```

HomeView.vue

```typescript
import {useStore} from 'vuex';

const store = useStore();
const list = computed(() => {
  return store.state.columns;
});
```

GlobalHeader.vue

```typescript
const store = useStore();
const user = computed(() => {
    return store.state.user;
})
```

LoginView.vue

```typescript
// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  // console.log('表单提交结果',flag);
  if(flag){
    router.push('/');
    store.commit('login');
  }
}
```

# 6-12 使用Vuex getters

需求：

1. 根据动态路由参数的不同，在文章页面展示不同的页面信息

实现：

1. 在store中使用getter过滤数据
2. 在文章页面使用computed获取过滤过的数据

store配置文件

```typescript
  getters: {
    getColumnById : (state) => (id:number) => {
      return state.columns[id - 1];
    },
    getArticlesById : (state) => (id:number) => {
      return state.posts.filter((article) => {
        return article.columnId === id;
      });
    }
  },
```

文章页面

```typescript
<script lang="ts" setup>
import { GlobalDataProps } from "@/store";
import { computed } from "vue";
import { useRoute } from "vue-router";
import {useStore} from 'vuex';

const route = useRoute();
const store = useStore<GlobalDataProps>();
const id = route.params.id;

const userDetail = computed(() => {
    return store.getters.getColumnById(parseInt(id as string));
});

const userArticles = computed(() => {
    return store.getters.getArticlesById(parseInt(id as string));
})
</script>
```

# 6-13 添加新建文章页面

需求：

1. 在这个页面可以输入文章标题和内容
2. ValidateInput组件可以根据传入的props属性tag，显示text或者textarea

实现：

1. 调用ValidateForm组件和ValidateInput组件完成CreatePost页面
2. 调用ValidateInput组件时，传入tag属性

CreatePost.vue

```vue
<template>
    <div class="container">
        <ValidateForm @form-submit="handleFormSubmit">
            <template #title>
                <div>新建文章</div>
            </template>

            <ValidateInput type="text" :rules="titleRule" tag="input" v-model:modelValue="titleVal"
            placeholder="请输入文章标题"
            >
                <div>文章标题：</div>
            </ValidateInput>

            <ValidateInput type="text" :rules="detailRule" tag="textarea" v-model:modelValue="detailVal"
            placeholder="请输入文章详情"
            >
                <div>文章详情：</div>
            </ValidateInput>

            <template #submit>
                <el-button type="primary">发表文章</el-button>
            </template>
        </ValidateForm>
    </div>
</template>
<script lang="ts" setup>
import ValidateInput, { IRuleProp } from '@/components/ValidateInput.vue';
import ValidateForm from '@/components/ValidateForm.vue';
import { ref } from 'vue';

const titleRule: IRuleProp[] = [
    { type: 'required', message: '文章标题不能为空' }
]
const detailRule: IRuleProp[] = [
    { type: 'required', message: '文章详情不能为空' }
]

const titleVal = ref('');
const detailVal = ref('');
const handleFormSubmit = (result:boolean) => {
    console.log('发表文章校验结果：',result);
    
}
</script>
<style lang="scss" scoped>
</style>
```

# 6-15 配置路由守卫

需求：

1.  如果未登录，CreatePost页面无法访问，会跳转到登录界面
2. 如果已经登录，Login页面无法访问，会跳转到首页

实现：

1. 在路由配置中设置元数据
2. 根据元数据判断能否进入该路由

router配置文件

```typescript
import { createRouter, createWebHashHistory, RouteRecordRaw } from 'vue-router'
import HomeView from '../views/HomeView.vue'
import {useStore} from 'vuex'

const routes: Array<RouteRecordRaw> = [
  {
    path: '/',
    name: 'home',
    component: HomeView
  },
  {
    path: '/login',
    name: 'login',
    // route level code-splitting
    // this generates a separate chunk (about.[hash].js) for this route
    // which is lazy-loaded when the route is visited.
    component: () => import(/* webpackChunkName: "about" */ '../views/LoginView.vue'),
    meta:{requireNotLogin:true}
  },
  {
    path: '/column/:id',
    name: 'column',
    component: () => import('../views/ColumnDetailView.vue')
  },
  {
    path: '/create',
    name: 'create',
    component: () => import('../views/CreatePostView.vue'),
    meta:{requireLogin:true},//
  }
]

const router = createRouter({
  history: createWebHashHistory(),
  routes
});

router.beforeEach((to,from,next) => {
  const store = useStore();
  console.log();
  if(!store.state.user.isLogin && to.meta.requireLogin){
    next({name:'login'});
  }else if(store.state.user.isLogin && to.meta.requireNotLogin){
    next('/');
  } else {
    next();
  }
})

export default router
```

# 7-9 使用axios对项目进行改造

# 7-12 编写Loader组件

需求：在发起请求后网络卡顿时，显示一个正在加载的组件

实现：

1. Vuex中新增全局状态 loading
2. 配置axios拦截器，在发起请求时将loading改为true，请求响应时设置为false
3. 编写Loader组件，根据loading的值决定是否显示
4. 使用Teleport组件
5. 在setup函数中创建节点<div id='back'></div>，将其挂载到body中
6. 在onUnmounted函数中将id为back的元素移除

全局状态

```typescript
state: {
    columns: [],
    posts: [],
    user: { isLogin: true, name: 'jack' },
    loading:false,
  },
```

main.ts文件中对axios拦截器进行配置

```typescript
axios.interceptors.request.use(config => {
    config.params = {...config.params,icode:'71E023A54874772F'};

    store.state.loading = true;
    return config;
});
axios.interceptors.response.use(config => {
    store.state.loading = false;
    return config;
});
```

Loader组件，配合ElementPlus实现

```vue
<template>
    <Teleport to="#back">
        <el-table v-loading="loading" :data="tableData">
            <el-table-column prop="date" label="Date" width="180" />
            <el-table-column prop="name" label="Name" width="180" />
            <el-table-column prop="address" label="Address" />
        </el-table>
    </Teleport>
</template>
<script lang="ts" setup>
import { onUnmounted, ref } from 'vue'

const loading = ref(true)

const tableData = [
    {
        date: '2016-05-02',
        name: 'John Smith',
        address: 'No.1518,  Jinshajiang Road, Putuo District',
    },
    {
        date: '2016-05-04',
        name: 'John Smith',
        address: 'No.1518,  Jinshajiang Road, Putuo District',
    },
    {
        date: '2016-05-01',
        name: 'John Smith',
        address: 'No.1518,  Jinshajiang Road, Putuo District',
    },
]
const div = document.createElement('div');
div.id = 'back';
document.body.appendChild(div);
onUnmounted(() => {
    document.body.removeChild(div);
})

</script>
<style lang="scss" scoped>
.el-table {
    position: absolute;
    width: 100%;
    height: 100%;
    z-index: 100;
    background: black;
    opacity: 0.6;
}
</style>
```

# 8-1 获取token

需求：发送登录请求，从响应数据中获取token，并设置为全局状态中的token

实现：

1. 在登录页面使用store.dispatch()传递登录页面数据
2. 在store配置文件的action中接收数据，并提交post请求
3. 将post请求返回的数据使用commit提交给mutation中的login
4. 在login函数中更改全局状态token

```typescript
//登录页面
// 处理表单组件注册的事件
const handleFormSubmit = (flag:boolean) => {
  // console.log('表单提交结果',flag);
  if(flag){
    store.dispatch('login',{
      email:emailVal.value,
      password:passwordVal.value,
    }).then(() => {
      router.push('/');
    })
  }
}

//store配置文件
	async login(context,rawData){
      const {data} = await axios.post('/user/login',rawData);
      context.commit('login',data.data.token);      
    }
    
    login(state,rawData){
      state.token = rawData;
    }
```

# 8-3 登录之axios设置通用的header

需求：GlobalHeader组件中在登录后显示当前用户的姓名

实现：

1. 根据获取到的token设置axios通用header
2. 向服务器发送请求，获取用户数据
3. 更新全局状态中的user
4. 首页获取user以属性方式传递给子组件GlobalHeader
5. GlobalHeader通过接收的属性渲染出用户姓名

```
login(state,rawData){
      state.token = rawData;//更新全局状态中的token

      // 将获取到的token设置到axios的通用请求头中
      axios.defaults.headers.common['Authorization'] = `Bearer ` + rawData;
    },
```

# 8-4 登录之持久化登录状态

需求：用户登录一次之后，刷新浏览器会自动登录

实现：

1. 第一次登录时，获取token，存储到localStorage中
2. 再次刷新浏览器，先读取本地的token值，如果token存在，根据token来获取用户信息，自动登录

```typescript
    login(state,rawData){
      state.token = rawData;//更新全局状态中的token
      localStorage.setItem('token',rawData);//将首次登录获取的token存储到localStorage中

      // 将获取到的token设置到axios的通用请求头中
      axios.defaults.headers.common['Authorization'] = `Bearer ` + rawData;
    },
```

```typescript
  state: {
    // 初始化全局状态中的token
    token: localStorage.getItem('token') || '',
    columns: [],
    posts: [],
    user: { isLogin: false},
    loading:false,
  },
```

```typescript
////在首页加载时获取token
const token = computed(() => store.state.token);//
onMounted(() => {
  // 如果用户没有登陆，但是浏览器中有token，那么自动登录
  if(!user.value.isLogin && token.value){
    // 将获取到的token设置到axios的通用请求头中
    axios.defaults.headers.common['Authorization'] = `Bearer ` + token.value;
    store.dispatch('fetchCurUser');
  }
})
```

# 8-5 通用错误处理

需求：在请求出现错误时，获取错误信息，并显示

实现：

1. axios拦截器配置response的err情况
2. 更新全局状态中的error
3. 将全局状态中的error中的message显示到页面

```typescript
axios.interceptors.response.use(config => {
    store.state.loading = false;
    return config;
},err => {//响应出现错误时进行拦截，并且更新全局状态中的error
  console.log('拦截器error：',err);
  const error = err.response.data.error;
  store.commit('setError',{status:true,message:error});
  store.state.loading = false;
  return Promise.reject(error);
});
```

# 8-6 创建Message组件

需求：当出现请求错误时，出现一个提示错误信息的组件，点击可以消失

实现：

1. 编写Message组件
2. Login组件调用时，传入错误信息，控制显示与隐藏

Message组件

```vue
<template>
    <Teleport to="#message">
        <div v-if="isVisible" class="message">
            {{ message }}
            <el-icon @click="hide" color="red"><CircleCloseFilled /></el-icon>
        </div>
    </Teleport>
</template>
<script setup lang="ts">
import { CircleCloseFilled} from "@element-plus/icons-vue";
import { ref,defineProps, onUnmounted } from "vue";

const isVisible = ref(true);
const props = defineProps({
    message:{
        type:String,
        required:true,
    }
})

const hide = () => {
    isVisible.value = false;
}
// 创建message元素
const div = document.createElement('div');
div.id = 'message';
document.body.appendChild(div);

onUnmounted(() => {
    document.body.removeChild(div);
})
</script>
<style lang="scss" scoped>
.message{
    position:absolute;
    width: 300px;
    height: 50px;
    background:pink;
    top: 0;
    margin: 0 auto;
    left: 50%;
    transform: translateX(-50%);
    text-align: center;
    line-height: 50px;
}
</style>
```

# 8-7 Message组件改进为函数调用形式

需求：可以使用TS代码调用Message组件，传入需要的值

实现：

1. 编写UseCreateMessage的文件
2. 在使用Message组件的地方，调用导出的函数

UseCreateMessage.ts文件

```typescript
import { createApp } from "vue";
import MessageComponent from '../components/MessageComponent.vue';

export type MessageType = 'success' | 'error' | 'default';
export const createMessage = (type:MessageType,message:string,timeout = 2000) => {
    const messageInstance = createApp(MessageComponent,{
        message:message,
        type:type,
    });

    const div = document.createElement('div');
    document.body.appendChild(div);
    messageInstance.mount(div);

    setTimeout(() => {
        messageInstance.unmount();
        document.body.removeChild(div);
    },timeout);
}
```

Login组件中使用TS代码调用组件

```typescript
// 处理表单组件注册的事件
const handleFormSubmit = (flag: boolean) => {
  // console.log('表单提交结果',flag);
  if (flag) {
    store.dispatch('loginAndFetch', {
      email: emailVal.value,
      password: passwordVal.value,
    }).then(() => {
      // 使用代码调用组件
      createMessage('success','登录成功，2秒后跳转！');
      setTimeout(() => {
        router.push('/');
      },2000);
    }).catch(err => {
      console.log('login组件error',err);
      errorMessage.value = err;
    })
  }
}
```

首页中使用

```typescript
const error = computed(() => store.state.error);
watch(() => error.value.status,() => {
  const {status,message} = error.value;
  if(status && message){
    createMessage('error',message);
  }
})
```

# 8-10 使用h函数改造UseCreateMessage

使用createApp函数创建出来的是组件实例

使用h或者createVNode函数创建的是虚拟节点

改造后的UseCreateMessage

```typescript
// 使用h函数和render函数改造
import { h,render } from "vue";
import MessageComponent from '../components/MessageComponent.vue';

export type MessageType = 'success' | 'error' | 'default';
export const createMessage = (type:MessageType,message:string,timeout = 2000) => {
    const messageVNode = h(MessageComponent,{
        message:message,
        type:type,
    });

    const div = document.createElement('div');
    document.body.appendChild(div);
    render(messageVNode,div);

    const destroyMessageVNode = () => {
        render(null,div);
        document.body.removeChild(div);
    }

    setTimeout(() => {
        destroyMessageVNode();
    },timeout);

    return destroyMessageVNode;
}

// 使用 createApp来创建组件实例
// import { createApp } from "vue";
// import MessageComponent from '../components/MessageComponent.vue';

// export type MessageType = 'success' | 'error' | 'default';
// export const createMessage = (type:MessageType,message:string,timeout = 2000) => {
//     const messageInstance = createApp(MessageComponent,{
//         message:message,
//         type:type,
//     });

//     const div = document.createElement('div');
//     document.body.appendChild(div);
//     messageInstance.mount(div);

//     setTimeout(() => {
//         messageInstance.unmount();
//         document.body.removeChild(div);
//     },timeout);
// }
```

# 9-2 上传文件

需求：选择本地的文件上传到服务器

实现：

1. Input选择type为file
2. 监听change事件
3. 处理change事件，通过e:Event对象获取files，取第一个file，
4. 将file添加到FormData对象中，使用axios发送post请求到后端

```vue
<input type="file" name="file" @change.prevent="handleFileChange"/>
```

````typescript
const handleFileChange = (e:Event) => {
    const target = e.target as HTMLInputElement;
    const files = target.files;
    if(files){
        const uploadedFile = files[0];
        const formData = new FormData();
        formData.append(uploadedFile.name,uploadedFile);
        axios.post('/upload',formData,{
            headers:{
                'Content-Type': 'multipart/form-data'
            }
        }).then(res => {
            console.log(res);
        }).catch(err => {
            console.log(err);
            
        })
    }
}
````

# 9-3 Uploader组件-第一部分

需求：

1. 封装Uploader组件
2. 初始显示 点击上传 字样
3. 上传过程中显示 正在上传
4. 失败显示 上传失败，成功显示 上传成功

实现：

1. file类型的Input输入框暂时无法改变文本内容
2. 通过给Input输入框设置ref='fileInput'属性来获取Input的DOM的对象
3. 设置button按钮，点击button按钮触发fileInput的click事件
4. 通过改变button按钮的文本内容实现上述需求

```vue
<template>
    <input type="file" ref="fileInput"
    @change.prevent="handleFileChange"
    class="input"
    />
    <button @click="triggerUpload">
        <span v-if="fileStatus==='ready'">点击上传</span>
        <span v-else-if="fileStatus==='loading'">正在上传</span>
        <span v-else-if="fileStatus==='success'">上传成功</span>
        <span v-else-if="fileStatus==='error'">上传失败</span>
    </button>
</template>
<script lang="ts" setup>
import { ref, defineProps } from 'vue'
import axios from 'axios';

const props = defineProps({
    action:{
        type:String,
    }
})

type UploadStatus = 'ready' | 'loading' | 'success' | 'error';
const fileInput = ref<null | HTMLInputElement>(null);
const fileStatus = ref<UploadStatus>('ready');
const triggerUpload = () => {
    fileInput.value.click();
}

const handleFileChange = (e:Event) => {
    const target = e.target as HTMLInputElement;
    const files = target.files;
    if(files){
        fileStatus.value = 'loading';
        const uploadedFile = files[0];
        const formData = new FormData();
        formData.append(uploadedFile.name,uploadedFile);
        axios.post(props.action,formData,{
            headers:{
                'Content-Type': 'multipart/form-data'
            }
        }).then(res => {
            console.log(res);
            fileStatus.value = 'success';
        }).catch(err => {
            console.log(err);
            fileStatus.value = 'error';
        }).finally(() => {
            if(fileInput.value){
                fileInput.value.value = '';
            }
        })
    }
}
</script>
<style scoped lang="scss">
.input{
    display: none;
}
</style>
```

# 9-4 Uploader组件第二部分

需求：

1. 调用Uploader组件时，可以传入自定义函数对文件类型进行检测
2. 不符合时，弹出消息提示
3. 文件上传成功和失败都有消息提示

实现：

1. Uploader组件接收一个函数，传入文件类型的参数，返回布尔值
2. Uploader组件注册两个事件
3. 父组件监听事件，并使用createMessage工具方法创建消息组件，并弹出

Uploader组件

```typescript
const props = defineProps({
    action:{
        type:String,
    },
    beforeUpload:{
        type:Function as PropType<CheckFile>,
    }
});
const emit = defineEmits(['file-upload-success','file-upload-fail']);
```

父组件CreatePost

```typescript
const beforeUpload = (file:File):boolean => {
    const isJpg = file.type === 'image/jpeg';
    if(!isJpg){
        createMessage('error',"图片只能是jpg格式");
    }
    return isJpg;
}

const onFileUploadSuccess = (data:ResponseType<ImageProps>):void => {
    createMessage('success',`上传图片ID为${data.data._id}`);
}
const onFileUploadFail = (err) => {
    createMessage('error',err);
}
```

# 9-5 Uploader组件第三部分：自定义模版

需求：

1. 使用组件时可以传入订制的元素，没有传入则按照默认情况
2. 上传成功后，显示图片

实现：

1. 使用具名插槽、具名作用域插槽
2. 作用域插槽将值传递给父组件，父组件显示图片

```vue
//Uploader组件
<template>
    <input type="file" ref="fileInput"
    @change.prevent="handleFileChange"
    class="input"
    />
    <button @click="triggerUpload">
        <slot  v-if="fileStatus==='ready'" name="ready">
            <span>点击上传</span>
        </slot>
        <slot v-else-if="fileStatus==='loading'" name="loading">
            <span>正在上传...</span>
        </slot>
        <slot
        :uplodaedData="uploadData"
        v-else-if="fileStatus==='success'" name="succss">
            <span>上传成功</span>
        </slot>
        <slot v-else-if="fileStatus==='error'" name="error">
            <span>上传失败</span>
        </slot>
    </button>
</template>
```

父组件：CreatePost组件

```vue
        <UploaderView 
        @file-upload-success="onFileUploadSuccess"
        @file-upload-fail="onFileUploadFail"
        action="/upload" 
        :beforeUpload="beforeUpload">
            <template #succss="soltProps"> 
                <img :src="soltProps.uplodaedData.data.url"/>
            </template>
        </UploaderView>
```

# 9-6 改进路由验证系统

需求：根据路由验证流程图改进路由验证系统

![](D:\project\Vue3TSzhuanlan\bowen\version-img\9-6路由验证流程图.png)

实现：

路由配置文件：

```typescript
router.beforeEach((to,from,next) => {
  const store = useStore();
  const {user,token} = store.state;
  const {requireLogin,requireNotLogin} = to.meta;

  if(!user.isLogin){
    if(token){
      axios.defaults.headers.common.Authorization = `Bearer ${token}`;
      store.dispatch('fetchCurUser').then(() => {
        if(requireNotLogin){
          next('/');
        }else{
          next();
        }
      }).catch(err => {
        console.log(err);
        localStorage.removeItem('token');
        next('login');
      })
    }else{
      if(requireLogin){
        next('login');
      }else{
        next();
      }
    }
  }else{
    if(requireNotLogin){
      next('/');
    }else{
      next();
    }
  }
})
```

# 9-8-1 创建文章最后流程1

需求：

1. 文件不符合要求时，弹出消息框提示具体问题
2. 大小不符，或者格式不符

实现：

1. 根据接收的file参数，检查文件格式和大小
2. 根据错误类型，调用createMessage函数弹出对应错误提示框

helper.ts文件

```typescript
interface checkCondition {
    format?:string[];
    size?:number;
}
type ErrorType = 'size' | 'format' | null;
export function beforeUploadCheck(file:File,condition:checkCondition){
    const {format,size} = condition;
    const isValidFormat = format ? format.includes(file.type) : true;
    const isValidSize = size ? (file.size / 1024 / 1024 < size) : true;
    let error:ErrorType = null;
    if(!isValidFormat){
        error = 'format';
    }
    if(!isValidSize){
        error = 'size';
    }
    return {
        passed: isValidFormat && isValidSize,
        error,
    }
}
```

createPostView.vue

```typescript
const beforeUpload = (file:File):boolean => {
    const result = beforeUploadCheck(file,{format:['image/jpeg', 'image/png'],size:1});
    const {passed,error} = result;
    if(error === 'format'){
        createMessage('error','上传图片只能是 JPG/PNG 格式!');
    }
    if(error === 'size'){
        createMessage('error','上传图片大小不能超过 1Mb!');
    }
    return passed;
}
```

# 9-8-2 创建文章最后2

需求：

1. 将用户上传的图片，编辑的标题和内容，提交到服务器

实现：

1. 获取数据，提交axios post请求

CreatePostView

```typescript
const handleFormSubmit = (result:boolean) => {
    if(result){
        const {column,_id} = store.state.user;
        if(column){
            const newPost:PostProps = {
                title:titleVal.value,
                content:detailVal.value,
                column,
                author:_id,
            }
            if(imageId){
                newPost.image = imageId;
            }
            store.dispatch('createPost',newPost).then(() => {
                createMessage('success','发表成功，2秒后跳转到文章！');
                setTimeout(() => {
                    router.push({name:'column',params:{id:column}});
                },2000);
            })
        }
    }
}

const onFileUploadSuccess = (data:ResponseType<ImageProps>):void => {
    imageId = data.data._id;//图片上传成功，将id取出来用于后序提交文章
    createMessage('success',`上传图片ID为${data.data._id}`);
}
```

store配置文件

```typescript
async createPost(context,rawData){
      axios.post('/posts',rawData);
    }
```

# 9-9 编写文章详情页

根据路由参数发起请求，获取文章信息，渲染到页面

PostDeatail.vue

```vue
<template>
    <div>文章详情</div>
    <div class="post-detail">
        <div class="header">
            <div class="img">
                <img :src="post.image?.url"/>
            </div>
            <div class="title">
                <h2>{{ post.title }}</h2>
            </div>
        </div>
        <div class="author">
            <div class="left">
                <img :src="post.author?.avatar?.url"/>
                <h5>{{ post.author?.nickName }}</h5>
            </div>
            <div class="right">
                {{ post.createdAt }}
            </div>
        </div>
        <div class="content" v-html="post?.content">
        </div>
    </div>
</template>
<script setup lang="ts">
import { computed, reactive, toRefs, watchEffect } from "vue";
import { useRoute } from "vue-router";
import axios from 'axios';
import MarkDownIt from 'markdown-it';


const route = useRoute();
const md = new MarkDownIt();

const postObj = reactive({post:{}});
const {post} = toRefs(postObj);
const getCurPost = async () => {
    const data = await axios.get(`/posts/${route.params.id}`);
    postObj.post = data.data.data;
}
watchEffect(() => {
    getCurPost();
});
</script>
<style lang="scss" scoped>
.post-detail{
    width: 800px;
    border:1px solid #000;
    margin: 0 auto;
    .header{
        border:1px solid #000;
        img{
            width: 800px;
        }
    }
    .author{
        border:1px solid #000;
        margin-top: 30px;
        display: flex;
        justify-content: space-between;
        align-items: center;

        .left{
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    }
    .content{
        margin-top: 30px;
    }
}
</style>
```

# 10-1 添加编辑和删除区域

需求：

1. 增加编辑和删除按钮，这一区域只有用户_id等于该文章的作者的id才会显示
2. 点击编辑按钮会进入创建文章页面，并携带参数（文章的id）

实现：

1. 计算属性，返回两者的比较结果，根据结果决定是否显示

2. <router-link 

    ​        :to="{name:'create',query:{id:post._id}}"

     \>

PostDetailView.vue

```vue
<div class="editor" v-if="isEditorVisible">
            <el-button type="success">
                <router-link 
                :to="{name:'create',query:{id:post._id}}"
                >
                    编辑
                </router-link>
            </el-button>
            <el-button type="danger">删除</el-button>
        </div>
       
const isEditorVisible = computed(() => {
    const userId = store.state.user._id;
    if(post.value && post.value.author){
        const curAuthor = postObj.post.author as UserProps;
        return curAuthor._id === userId;
    }
    return false;
})       
```

# 10-2 修改文章编码 改进Uploader组件

需求：

1. 如果是编辑文章的模式，Uploader组件会显示当前文章的图片

实现：

1. 根据route.query.id判断是否是编辑模式
2. 如果是，那么根据route.query.id发起get请求获取文章数据
3. 将图片的url传递给子组件Uploader
4. Uploader接收到数据，显示图片

CreatePost页面

```vue
const curPostImgUrl = ref('');
const getPost = async () => {
    if(isEditMode){
        const {data} = await axios.get(`/posts/${route.query.id}`);
        curPostImgUrl.value = data.data.image.url;
    }
}
watchEffect(() => {
    getPost();
})

       <UploaderComponent
        :curImgUrl="curPostImgUrl" 
        @file-upload-success="onFileUploadSuccess"
        @file-upload-fail="onFileUploadFail"
        action="/upload" 
        :beforeUpload="beforeUpload">
            <template #succss="soltProps"> 
                <img :src="soltProps.uplodaedImgUrl"/>
            </template>
        </UploaderComponent>
```

Uploader组件

```vue
const props = defineProps({
    action:{
        type:String,
    },
    beforeUpload:{
        type:Function as PropType<CheckFile>,
    },
    curImgUrl:{//新增
        type:String,
    }
});

const uplodaedImgUrl = ref(props.curImgUrl || '');//改动
const fileInput = ref<null | HTMLInputElement>(null);
const fileStatus = ref<UploadStatus>(props.curImgUrl ? 'success' : 'ready');//改动

watch(() => props.curImgUrl,(newValue) => {//新增
    if(newValue){
        fileStatus.value = 'success';
        uplodaedImgUrl.value = newValue;
    }
})
```

# 10-3 修改文章编码 改进ValidateInput组件

需求：如果是编辑模式，Input组件会自动填充当前文章的标题、内容

实现：

1. 根据route.query.id判断是否是编辑模式
2. 如果是，那么根据route.query.id发起get请求获取文章数据
3. 将文章的title、content传递给子组件ValidateInput
4. ValidateInput接收到数据，显示title、content

CreatePostView

```typescript
const getPost = async () => {
    if(isEditMode){
        const {data} = await axios.get(`/posts/${route.query.id}`);
        curPostImgUrl.value = data.data.image.url;
        console.log(data.data);
        titleVal.value = data.data.title;
        detailVal.value = data.data.content;
    }
}
watchEffect(() => {
    getPost();
})
```

ValidateInput组件

```typescript
// 响应式的信息，
const inputRef = reactive({
    val: props.modelValue || "",//输入框绑定的值
    message:'',//绑定的错误提示信息
    error:false,//输入信息是佛正确
});
watch(() => props.modelValue,(newValue) => {
    inputRef.val = newValue || '';
})
```

# 10-4 修改文章编码 完成编辑功能

需求：修改文章内容后，更新文章数据

实现：

1. 提交patch请求，传入文章id和文章新内容，更新数据

CreatePostView

```typescript
const getPost = async () => {
    if(isEditMode){
        const {data} = await axios.get(`/posts/${route.query.id}`);
        curPostImgUrl.value = data.data.image?.url;
        console.log(data.data);
        titleVal.value = data.data.title;
        detailVal.value = data.data.content;
        postId = data.data._id;
    }
}
watchEffect(() => {
    getPost();
})

const handleFormSubmit = (result:boolean) => {
    if(result){
        const {column,_id} = store.state.user;
        if(column){
            const newPost:PostProps = {
                title:titleVal.value,
                content:detailVal.value,
                column,
                author:_id,
            }
            if(imageId){
                newPost.image = imageId;
            }
            let p:Promise<any>;
            if(!isEditMode){
                p = store.dispatch('createPost',newPost);
            }else{
                newPost._id = postId;
                p = store.dispatch('updatePost',{id:postId,newPost:newPost});
            }

            p.then(() => {
                createMessage('success','发表成功，2秒后跳转到文章！');
                setTimeout(() => {
                    router.push({name:'column',params:{id:column}});
                },2000);
            })
        }
    }
}
```

store配置文件

```typescript
async updatePost(context,{id,newPost}){
      axios.patch(`/posts/${id}`,newPost);
    }
```




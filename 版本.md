# 4-5ColumnList组件编码

使用props将App组件内的数据TestData传递到ColumnList子组件；

子组件定义接口ColumnProps

子组件使用defineProps接收，并使用PropType进一步确定list的类型为ColumnProps类型的数组；

此版本知识点：组件的定义和使用、props传值、interface、类型断言、TypeScript工具类型PropType<T>

```vue
<template>
    <div>
        <ul>
            <li v-for="column in list" :key="column.id">
                <img :src="column.avatar" :alt="column.title">
                <h5>{{ column.title }}</h5>
                <p>{{ column.description }}</p>
                <a href="#">进入专栏</a>
            </li>
        </ul>
    </div>
</template>
<script setup lang="ts">
import { PropType } from 'vue'

interface ColumnProps {
    id:number;
    title:string;
    avatar:string;
    description:string;
}

// eslint-disable-next-line no-undef
const props = defineProps({
  list: {
    type: Array as PropType<ColumnProps[]>,
    required: true
  }
})
</script>

```

```
<template>
  <div id="app">
    <ColumnList :list="testData"/>
    <div></div>
  </div>
</template>

<script lang="ts" setup>
import ColumnList, { ColumnProps } from './components/ColumnList.vue'
import 'bootstrap/dist/css/bootstrap.min.css'

const testData: ColumnProps[] = [
  {
    id: 1,
    title: 'test1的专栏',
    description: '这是的test1专栏，有一段非常有意思的简介，可以更新一下欧, 这是的test1专栏，有一段非常有意思的简介，可以更新一下欧',
    avatar: 'http://vue-maker.oss-cn-hangzhou.aliyuncs.com/vue-marker/5ee22dd58b3c4520912b9470.jpg?x-oss-process=image/resize,m_pad,h_150,w_150'
  },
  {
    id: 2,
    title: 'test2的专栏',
    description: '这是的test2专栏，有一段非常有意思的简介，可以更新一下欧',
    avatar: 'http://vue-maker.oss-cn-hangzhou.aliyuncs.com/vue-marker/5ee22dd58b3c4520912b9470.jpg?x-oss-process=image/resize,m_pad,h_100,w_100'
  }
]
</script>
```

# 4-6ColumnList组件使用Bootstrap美化

（一）Vue3项目安装Bootstrap

```
npm i bootstrap@5.3.0-alpha1
```

在main.ts文件中引入

```ts
import { createApp } from 'vue'
import App from './App.vue'
import 'bootstrap'
import 'bootstrap/dist/css/bootstrap.min.css'

createApp(App).mount('#app')
```

（二）设置默认图片

需求：当子组件接收的数据中缺少图片路径时，将其设置为默认图片

完成方式：

1. 更改接口ColumnProps，将avatar属性设置为可选属性
2. 使用computed加工list，如果list的avatar属性为空，则将其设置为默认路径
3. 使用require函数获取本地assets中的资源
4. v-for不在循环list，而是循环columnList

```typescript
interface ColumnProps {
  id: number;
  title: string;
  avatar?: string;//将avatar属性设置为可选属性
  description: string;
}
```

```typescript
const columnList = computed(() => {
    return props.list.map(item => {
        if(!item.avatar){
            item.avatar = require('@/assets/column.jpg');
        }
        return item;
    });
});
```

```vue
<template>
  <div class="row">
      <!-- 循环columnList -->
    <div class="col-4 mb-4" v-for="column in columnList" :key="column.id">
      <div class="card h-100 shadow-sm">
        <div class="card-body">
          <img class="card-img-top rounded-circle border border-light my-3" :src="column.avatar" :alt="column.title" />
          <h5 class="card-title">{{ column.title }}</h5>
          <p class="card-text">{{ column.description }}</p>
          <a class="btn btn-outline-primary" href="#">进入专栏</a>
        </div>
      </div>
    </div>
  </div>
</template>
```

# 4-7Global-Header组件编码

需求：编写一个全局通用的Header组件，根据父组件的传值显示不同内容

完成：

1. IUser类型
2. 子组件props接收，使用v-if指令根据user的数据决定是显示登录按钮，还是下拉菜单

```typescript
const userData:IUser = {//父组件中的数据
  isLogin:true,
  name:'jack',
  id:101
} 
```

```typescript
<script lang="ts" setup>
import { PropType } from 'vue';
interface IUser {
    isLogin: boolean;
    name?: string;
    id?: number;
}

// eslint-disable-next-line no-undef
const props = defineProps({
    user: {
        type: Object as PropType<IUser>,
        requerid: true
    }
});
</script>
```

# 4-8Dropdown组件基本功能编码

需求：将下拉菜单抽离为组件，编写为Dropdown组件

```typescript
<DropDown :name="user.name" />
```

```typescript
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps(['name']);
</script>
```

# 4-9Dropdown组件添加DropdownItem

需求：将下拉菜单的选项抽离为组件

完成：

1. 使用slot传递元素
2. ElementPlus 中的下拉菜单选项有disabled属性，可以控制禁用
3. DropdownItem组件使用props接收父组件的数据，决定是否禁用

父组件

```vue
const isDisabled = ref(true);

            <div v-else>
                <DropDown :name="user.name">
                    <DropdownItem>
                        <a>新建文章</a>
                    </DropdownItem>
                    <DropdownItem :disabled="isDisabled">
                        <a>管理账户</a>
                    </DropdownItem>
                    <DropdownItem>
                        <a>退出登录</a>
                    </DropdownItem>
                </DropDown>
            </div>
```

Dropdown组件

````vue
<template>
  <el-dropdown split-button type="primary">
    欢迎你 {{ name }}
    <template #dropdown>
      <el-dropdown-menu>
        <slot></slot>
      </el-dropdown-menu>
    </template>
  </el-dropdown>
</template>
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps(['name']);
</script>
````

DropdownItem组件

```vue
<template>
    <el-dropdown-item :disabled="disabled">
        <slot></slot>
    </el-dropdown-item>
</template>
<script setup lang="ts">
// eslint-disable-next-line no-undef
const props = defineProps({
    disabled: {
        type: Boolean,
        default: false,
    }
})
</script>
```

# 5-3抽象验证规则

需求：抽离表单组件，抽离输入框组件；父组件在调用输入框组件时，要传入数组形式的验证规则，输入框组件根据根据验证规则验证输入的信息，并给出对应的错误提示。

子组件

```vue
<template>
    <div class="form-input">
        <slot></slot>
        <el-input 
        @blur="validateEmail"
        v-model="inputRef.val" autosize type="textarea" placeholder="Please input" />
        <p v-if="inputRef.error" v-text="inputRef.message"></p>
    </div>
</template>
<script setup lang="ts">
import { PropType, reactive} from 'vue';

const emailReg = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;

// 定义验证规则的接口
interface IRuleProp{
    type:'required' | 'email';
    message:string;
}
// 接受父组件传来的值，包括验证规则
// eslint-disable-next-line no-undef
const props = defineProps({
    rules:Array as PropType<IRuleProp[]>,
});

// 响应式的信息，
const inputRef = reactive({
    val:"",//输入框绑定的值
    message:'',//绑定的错误提示信息
    error:false,//输入信息是佛正确
});
// 遍历传入的数组，检验输入值是否符合每一个规则
const validateEmail = () => {
    if(props.rules){
        let allPassed = props.rules.every(rule => {
            let passed = true;
            inputRef.message = rule.message;
            switch(rule.type){
                case 'required':
                    passed = (inputRef.val !== '');
                    break;
                case 'email':
                    passed = emailReg.test(inputRef.val);
                    break;
                default:
                    break;
            }

            return passed;
        })
        inputRef.error = !allPassed;
    }
}
// const validateEmail = () => {
//     if(emialRef.val.trim() === ''){
//         emialRef.error = true;
//         emialRef.message = 'Can not be empty!!!';
//     }else if(!emailReg.test(emialRef.val)){
//         emialRef.error = true;
//         emialRef.message = 'Should be valid email!!!';
//     }
// }
</script>
```

表单验证组件

```vue
<template>
    <div class="container">
        <div class="form">
            <div class="title">登录博文专栏</div>
            <slot></slot>
            <el-button color="#626aef" >Default</el-button>
        </div>
    </div>
</template>
```

App.vue组件

```vue
<template>
  <div id="app">
    <ValidateForm>
      <ValidateInput :rules="emailRules">
        <div>邮箱：</div>
      </ValidateInput>
      <ValidateInput>
        <div>密码：</div>
      </ValidateInput>
    </ValidateForm>
  </div>
</template>

<script lang="ts" setup>
// 传给表单输入框验证的 校验规则
const emailRules: IRuleProp[] = [
  { type: 'required', message: '电子邮箱地址不能为空' },
  { type: 'email', message: '请输入正确的电子邮箱格式' }
]
</script>
```

# 5-4 用输入框的值更新父组件数据

需求：子组件内输入框内容更新后，父组件对应数据也要变

完成：

1. 输入框组件注册事件
2. @keyup触发注册的事件
3. 使用emit发送最新数据
4. 父组件数据被更新

````typescript
// eslint-disable-next-line no-undef
const emit = defineEmits(['updateVal'])
// 监听输入框的数据更新
const updateVal = () => {
    emit('updateVal',inputRef.val);
}
````

```typescript
//父组件
// 表单数据之邮箱数据的响应式
const modelVal = ref('init email');
const handleUpdateVal = (newVal:string) => {
  modelVal.value = newVal;
}
```

